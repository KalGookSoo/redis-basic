# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

- [01-1 Redis란 무엇인가](#01-1-redis란-무엇인가)
- [01-2 설치와 기본 사용법](#01-2-설치와-기본-사용법)
- [01-3 데이터 타입 개요](#01-3-데이터-타입-개요)
- [02-1 자료구조 심화와 사용 시나리오](#02-1-자료구조-심화와-사용-시나리오)
- [02-2 만료와 키 스페이스 관리](#02-2-만료와-키-스페이스-관리)
- [02-4 메시징: Pub/Sub과 Stream](#02-4-메시징-pubsub과-stream)
- [02-3 트랜잭션, Lua, 파이프라이닝](#02-3-트랜잭션-lua-파이프라이닝)
- [03-1 메모리와 성능](#03-1-메모리와-성능)

### 01-1 Redis란 무엇인가

#### 문제 1
**문제**: Redis를 가장 정확히 설명하는 문장은 무엇인가?

**정답**: 인메모리 기반의 Key-Value 데이터 스토어로 다양한 자료구조를 제공한다.

**해설**:
- Redis는 메모리(RAM)를 주 저장소로 사용하는 인메모리 데이터 스토어이며, 초저지연과 높은 처리량을 제공합니다.
- 단순 Key-Value를 넘어 String, Hash, List, Set, Sorted Set, Bitmap, HyperLogLog, Geo, Stream 등 다양한 자료구조를 지원합니다.
- 관계형 DB가 아니며 SQL을 사용하지 않습니다.

#### 문제 2
**문제**: 다음 중 Redis의 핵심 특징으로 보기 어려운 것은?

**정답**: 모든 연산이 트랜잭션 로그를 통해 ACID를 완벽 보장

**해설**:
- Redis는 단일 스레드 이벤트 루프, 초저지연/고처리량, 다양한 자료구조 제공이 핵심 특징입니다.
- ACID 완전 보장은 전통적 RDBMS의 특성이며, Redis는 RDB/AOF 퍼시스턴스를 제공하지만 모든 연산에 대해 완전한 ACID 보장을 목표로 하지는 않습니다.

#### 문제 3
**문제**: [복수 응답] Redis를 사용하기 좋은 시나리오를 모두 고르세요.

**정답**: 세션 저장소로 사용자 세션을 빠르게 조회/저장, 랭킹/리더보드 구현, API 응답 캐싱을 통한 성능 개선, 실시간 알림/메시징 처리

**해설**:
- 세션 저장소: 빠른 조회/갱신에 적합하며 TTL을 활용하기 좋습니다.
- 랭킹/리더보드: Sorted Set(ZSet)으로 점수 기반 정렬과 범위 조회에 최적화되어 있습니다.
- API 응답 캐싱: 캐시 미스로 DB 부하를 줄이고 응답 시간을 개선합니다.
- 실시간 알림/메시징: Pub/Sub과 Stream으로 이벤트 스트림을 처리할 수 있습니다.
- 대규모 조인 중심 분석은 RDBMS/데이터 웨어하우스가 더 적합합니다.

### 01-2 설치와 기본 사용법

#### 문제 1
**문제**: Redis를 Docker로 실행할 때 외부에서 기본 포트로 접속하려면 올바른 명령은 무엇인가?

**정답**: docker run -it --rm -p 6379:6379 --name redis redis:latest

**해설**:
- `-p 6379:6379`로 호스트의 6379 포트를 컨테이너의 6379에 매핑해야 외부/호스트에서 접근할 수 있습니다.
- 포트를 매핑하지 않거나 다른 포트(예: 8080:6379)를 쓰면 기본 포트로는 접속할 수 없습니다.

#### 문제 2
**문제**: 운영 환경에서 많은 키를 조회해야 할 때 권장되는 방법은?

**정답**: SCAN 0 MATCH user:* COUNT 100

**해설**:
- KEYS는 전체 키스페이스를 블로킹 스캔하여 대규모 환경에서 성능 저하를 유발할 수 있습니다.
- SCAN은 커서 기반, 점진적(iterative) 스캔으로 이벤트 루프를 장시간 점유하지 않아 운영 환경에 적합합니다.

#### 문제 3
**문제**: [복수 응답] 다음 중 기본 사용법과 관련하여 옳은 것을 모두 고르세요.

**정답**: PING 명령은 연결 상태를 확인하며 일반적으로 PONG을 반환한다., SET key value EX 60은 key에 60초 만료 시간을 설정한다., redis-cli -a <password>로 인증이 필요한 서버에 접속할 수 있다.

**해설**:
- PING/PONG은 연결 및 서버 응답 상태를 확인하는 기본 수단입니다.
- `SET key value EX 60`은 키에 TTL을 설정합니다(서버 시계 기준 만료).
- `redis-cli -a <password>`로 requirepass/ACL이 설정된 서버에 인증 후 접속할 수 있습니다.
- KEYS는 운영 환경에서 권장되지 않습니다.
- FLUSHALL은 모든 DB를 비우며, 현재 선택된 DB만 지우는 것은 FLUSHDB입니다.

### 01-3 데이터 타입 개요

#### 문제 1
**문제**: Sorted Set(ZSet)을 사용하는 것이 가장 적절한 시나리오는 무엇인가?

**정답**: 순위 기반 리더보드 구현

**해설**:
- ZSet은 점수 기반 정렬과 범위 조회에 최적화되어 리더보드와 같은 순위 기능에 적합합니다.
- 단순 키-값 캐시는 String, 필드-값 객체 저장은 Hash, 중복 없는 태그 모음은 Set이 더 적절합니다.

#### 문제 2
**문제**: 다음 중 HyperLogLog(HLL)에 대한 설명으로 옳지 않은 것은?

**정답**: 각 원소를 정확히 저장하여 이후 개별 삭제가 가능하다.

**해설**:
- HLL은 원소 자체를 저장하지 않고 확률적 구조로 유니크 카디널리티를 추정합니다.
- 매우 적은 고정 메모리(약 12KB)로 큰 규모를 다룰 수 있지만, 개별 원소 조회/삭제는 불가합니다.
- UV(Unique Visitors) 추정 등 유니크 수 추정에 적합합니다.

#### 문제 3
**문제**: [복수 응답] 다음 중 집합(Set) 또는 정렬된 집합(ZSet)의 적절한 활용으로 옳은 것을 모두 고르세요.

**정답**: 공통 관심사 사용자를 구하기 위해 두 집합의 교집합을 구한다., 타임스탬프를 점수로 하여 최근 게시물을 범위 조회한다.

**해설**:
- Set: `SINTER`로 교집합을 구해 공통 관심사를 가진 유저를 찾을 수 있습니다.
- ZSet: 점수를 타임스탬프로 사용하면 최신 게시물을 범위로 효율적으로 조회할 수 있습니다.
- 사용자 객체의 세부 필드는 Hash가 적절합니다.
- 주변 5km 반경 검색은 Geo 타입이 적절합니다.
- 특정 날짜 활성 사용자 비트 기록은 Bitmap이 적절합니다.

### 02-1 자료구조 심화와 사용 시나리오

#### 문제 1
**문제**: ZSet의 내부 구현과 시간복잡도 설명으로 가장 알맞은 것은?

**정답**: skiplist와 dict 조합으로 삽입/삭제/순위 조회가 O(log N)이다.

**해설**:
- Redis의 Sorted Set은 skiplist와 해시 사전을 결합해 점수 순 정렬과 멤버→점수 조회를 모두 빠르게 지원합니다.
- 삽입/삭제/순위 조회는 대체로 O(log N), 범위 조회는 결과 크기에 비례합니다.
- 해시만으로 구현(O(1) 삽입)되거나 배열 기반 O(1) 범위 조회는 사실과 다릅니다.

#### 문제 2
**문제**: 대규모 컬렉션을 운영 환경에서 안전하게 순회하는 방법으로 가장 적절한 것은?

**정답**: HSCAN/SSCAN/ZSCAN으로 커서 기반 점진 순회

**해설**:
- SCAN 계열은 커서 기반 비차단 점진 순회를 제공하여 이벤트 루프 장시간 점유를 피합니다.
- KEYS/HGETALL은 큰 데이터에서 블로킹/비효율적일 수 있습니다. RANDOMKEY는 무작위 1개만 반환합니다.

#### 문제 3
**문제**: [복수 응답] 다음 중 주어진 시나리오에 대한 자료구조/명령 선택이 적절한 것을 모두 고르세요.

**정답**: Top 100 리더보드를 구하기 위해 ZREVRANGE leaderboard 0 99 WITHSCORES, 간단한 작업 큐를 블로킹 소비하려면 BRPOP queue:jobs 0, 여러 사용자 이름을 한 번에 읽기 위해 MGET user:1:name user:2:name

**해설**:
- 리더보드: ZREVRANGE로 높은 점수 순 상위 N을 효율적으로 조회할 수 있습니다.
- 큐 소비: BRPOP/BLPOP은 항목이 들어올 때까지 블로킹하는 소비자 패턴에 적합합니다.
- 대량 읽기: MGET은 여러 키를 한 번에 읽어 RTT를 줄입니다.
- 공통 유저 찾기에는 SINTER가 적합하고, SUNION은 합집합이므로 정답이 아닙니다.
- 일간 활성 사용자 "수" 집계는 Bitmap의 BITCOUNT가 어울리며 PFCOUNT는 유니크 카디널리티 추정(HLL)입니다.

### 02-2 만료와 키 스페이스 관리

#### 문제 1
**문제**: TTL/만료 관련 설명으로 옳은 것은 무엇인가?

**정답**: SET key value EX 60은 키에 60초 만료를 동시에 설정한다.

**해설**:
- EXPIRE/PEXPIRE는 각각 초/밀리초 단위 TTL을 설정합니다. SET EX/PX 옵션으로 값 설정과 TTL을 동시에 지정할 수 있습니다.
- TTL의 기준은 서버 시계이며, `TTL key`는 남은 초를, `PTTL key`는 남은 밀리초를 반환합니다.
- TTL -1은 만료가 없음을, -2는 키가 없음을 의미합니다.

#### 문제 2
**문제**: 키스페이스 알림을 받기 위해 필요한 설정으로 가장 올바른 것은?

**정답**: CONFIG SET notify-keyspace-events Exg를 사용하면 만료/삭제/일반 이벤트에 대한 키이벤트 채널 알림을 활성화할 수 있다.

**해설**:
- `notify-keyspace-events`는 기본값에서 대부분 비활성화되어 있으며, 필요한 플래그를 명시적으로 설정해야 합니다.
- `E`는 키이벤트 채널, `x`는 expired, `g`는 generic(DEL/EXPIRE 등)을 의미합니다. 조합에 따라 발행 범위를 조정합니다.
- 키스페이스 채널은 `__keyspace@<db>__:<key>`, 키이벤트 채널은 `__keyevent@<db>__:<event>` 형식입니다.

#### 문제 3
**문제**: [복수 응답] 다음 중 maxmemory-policy에 대한 설명으로 옳은 것을 모두 고르세요.

**정답**: volatile-ttl은 남은 TTL이 짧은 키부터 제거를 시도한다., noeviction은 메모리 초과 시 쓰기 명령이 오류를 반환할 수 있다., allkeys-lfu는 접근 빈도가 낮은 키를 우선 제거한다.

**해설**:
- allkeys-lru는 TTL 유무와 관계없이 모든 키 중에서 LRU 후보를 제거합니다(선택지의 진술과 반대). volatile-lru는 TTL 있는 키로 범위를 제한합니다.
- volatile-ttl은 남은 TTL이 짧은 키를 우선 제거합니다.
- noeviction은 쓰기 명령이 `OOM command not allowed`와 같은 오류를 반환할 수 있습니다.
- allkeys-lfu는 전체 키 중 접근 빈도가 낮은 키를 우선 제거합니다.
- volatile-random은 TTL이 설정된 키 중 무작위 제거이며, 전체 키 중 무작위는 allkeys-random입니다.

### 02-3 트랜잭션, Lua, 파이프라이닝

#### 문제 1
**문제**: Redis에서 `WATCH`를 사용한 트랜잭션 패턴에 대한 설명으로 가장 알맞은 것은?

**정답**: WATCH는 EXEC 전에 감시한 키 변경을 감지해 EXEC가 nil을 반환하도록 하며, 일반적으로 클라이언트에서 재시도 로직을 구현한다.

**해설**:
- `WATCH`는 낙관적 락으로, 감시한 키가 변경되면 `EXEC`은 실행되지 않고 `nil`을 반환합니다. 이는 충돌을 감지하고 안전하게 재시도하기 위한 메커니즘입니다.
- 자동 롤백 개념이 아닌, 애플리케이션 레벨에서 재시도/보상 로직을 설계해야 합니다.

#### 문제 2
**문제**: Lua 스크립트 실행(EVAL)에 대한 설명으로 옳은 것은?

**정답**: EVAL로 실행된 스크립트는 전체가 원자적으로 실행되며, 스크립트 내부에서 여러 명령을 호출할 수 있다.

**해설**:
- Redis는 단일 스레드 이벤트 루프에서 스크립트를 실행하며, 스크립트 동안 다른 클라이언트 명령이 개입하지 못하므로 원자성이 보장됩니다.
- 스크립트는 `redis.call`로 여러 명령을 조합할 수 있으며, 반복적으로 사용할 스크립트는 `SCRIPT LOAD` + `EVALSHA`로 캐시해 호출 성능을 높입니다.

#### 문제 3
**문제**: [복수 응답] 파이프라이닝에 대한 설명으로 옳은 것을 모두 고르세요.

**정답**: 파이프라이닝은 네트워크 왕복(RTT)을 줄여 처리량을 높일 수 있다., 너무 큰 파이프라인은 메모리 사용량과 지연을 증가시킬 수 있다., 파이프라이닝은 응답을 순서대로 받지만 중간에 오류가 섞일 수 있으므로 클라이언트에서 결과를 해석해야 한다.

**해설**:
- 파이프라이닝은 요청을 연속 전송하여 RTT 비용을 절감합니다.
- 대규모 파이프라인은 클라이언트/서버 메모리 버퍼를 증가시키고, 응답 처리 지연을 야기할 수 있습니다.
- 파이프라인은 원자성을 보장하지 않으며, 각 응답을 순서대로 확인하여 오류를 적절히 처리해야 합니다.

### 02-4 메시징: Pub/Sub과 Stream

#### 문제 1
**문제**: Pub/Sub에 대한 설명으로 가장 알맞은 것은?

**정답**: 브로드캐스트 기반으로 구독 중인 모든 구독자에게 전달되며 저장/ack이 없다.

**해설**:
- Pub/Sub은 채널을 구독 중인 클라이언트에게 즉시 브로드캐스트합니다.
- 메시지 저장/재전송/ack 메커니즘이 없어 오프라인 동안의 메시지는 상실됩니다.

#### 문제 2
**문제**: Streams 소비자 그룹에 대한 설명으로 옳은 것은?

**정답**: 미확인 메시지는 PEL에 남으며 XCLAIM/XAUTOCLAIM으로 재할당할 수 있다.

**해설**:
- 그룹 내 각 메시지는 한 소비자에게 할당되며, `XACK` 전까지 PEL에 머뭅니다.
- 타임아웃된 항목은 `XCLAIM`/`XAUTOCLAIM`으로 다른 소비자가 가져올 수 있어 내고장성을 높입니다.

#### 문제 3
**문제**: [복수 응답] Streams 운영과 백프레셔 관리에 대한 모범 사례를 모두 고르세요.

**정답**: XADD 시 MAXLEN ~ 옵션을 활용해 스트림 크기를 제한한다., XPENDING/XINFO로 적체와 느린 소비자를 모니터링한다., 재시도 한도를 넘긴 메시지는 DLQ로 이동시켜 별도 처리한다., 소비 속도가 느리면 XAUTOCLAIM으로 장기 보류 메시지를 재할당한다.

**해설**:
- 무한 성장 방지를 위해 트리밍 옵션을 사용합니다.
- PEL/컨슈머 상태를 모니터링하여 적체를 조기 감지합니다.
- 반복 실패 메시지는 DLQ로 분리해 시스템 건전성을 유지합니다.
- 재할당으로 장애/지연 컨슈머의 영향을 완화할 수 있습니다.

### 03-1 메모리와 성능

#### 문제 1
**문제**: Redis의 eviction 정책에 대한 설명으로 가장 알맞은 것은?

**정답**: volatile-ttl은 남은 TTL이 짧은 키부터 제거를 시도한다.

**해설**:
- volatile-ttl은 TTL이 설정된 키들 중 남은 TTL이 짧은 항목부터 제거 후보로 삼습니다.
- noeviction은 키를 제거하지 않고 쓰기 명령을 오류로 반환할 수 있습니다.
- allkeys-random은 임의 선택이며 접근 빈도와 무관합니다.
- allkeys-lfu는 TTL 유무와 상관없이 전체 키에서 낮은 빈도 키를 우선 제거합니다.

#### 문제 2
**문제**: lazy-free와 관련한 설명으로 옳은 것은?

**정답**: lazyfree-lazy-expire를 켜면 만료된 큰 키 메모리 해제를 백그라운드로 오프로드할 수 있다.

**해설**:
- lazy-free는 해제 비용이 큰 연산을 백그라운드 스레드로 넘겨 메인 이벤트 루프의 지연 스파이크를 줄입니다.
- 작은 키까지 항상 lazy-free로 처리하는 것은 아니며, 설정에 따라 동작 범위가 다릅니다.
- 메모리 누수를 일으키는 메커니즘이 아니며, 단지 해제 타이밍을 비동기로 전환합니다.

#### 문제 3
**문제**: [복수 응답] 성능 모니터링/진단에 대한 올바른 방법을 모두 고르세요.

**정답**: SLOWLOG로 임계치 초과 명령을 분석한다., LATENCY DOCTOR/HISTOGRAM으로 지연 스파이크 원인을 파악한다., INFO memory의 fragmentation_ratio를 확인해 단편화 상태를 점검한다.

**해설**:
- MONITOR는 실시간 모든 명령을 흘려 보내 부하가 크므로 상시 운영에 적합하지 않습니다.
- KEYS *는 블로킹 특성이 있어 운영에서 주기 실행은 금기입니다. SCAN 계열을 사용하세요.

